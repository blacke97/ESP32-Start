å½“ç„¶å¯ä»¥ï¼ä»¥ä¸‹æ˜¯ **7 ä¸ª ESP32 è¿›é˜¶é¡¹ç›®çš„å®Œæ•´å·¥ç¨‹æ–‡ä»¶ç»“æ„**ï¼Œæ¯ä¸ªé¡¹ç›®åŒ…å«ï¼š

- âœ… **é¡¹ç›®åç§°ä¸åŠŸèƒ½ç®€ä»‹**  
- âœ… **æ‰€éœ€ç¡¬ä»¶æ¸…å•**  
- âœ… **Arduino åº“ä¾èµ–ï¼ˆå«å®‰è£…æ–¹å¼ï¼‰**  
- âœ… **å®Œæ•´å¯è¿è¡Œä»£ç ï¼ˆ.ino æ–‡ä»¶ï¼‰**  
- âœ… **å…³é”®å¼•è„šå®šä¹‰è¯´æ˜**  
- âœ… **ä½¿ç”¨è¯´æ˜**

æ‰€æœ‰ä»£ç å‡åŸºäº **Arduino Core for ESP32**ï¼Œä½¿ç”¨ **PlatformIO æˆ– Arduino IDE å‡å¯ç¼–è¯‘è¿è¡Œ**ã€‚

---

## ğŸ“ é¡¹ç›® 1ï¼šæ™ºèƒ½å‘¼å¸ç¯ï¼ˆå¸¦æ¨¡å¼åˆ‡æ¢ï¼‰

### åŠŸèƒ½
PWM å‘¼å¸ç¯ + æŒ‰é”®çŸ­æŒ‰/é•¿æŒ‰åˆ‡æ¢æ¨¡å¼ï¼ˆå‘¼å¸ / å¸¸äº® / å¿«é—ªï¼‰

### ç¡¬ä»¶
- ESP32 å¼€å‘æ¿
- LED + 220Î© ç”µé˜»
- è½»è§¦æŒ‰é”® + 10kÎ© ç”µé˜»ï¼ˆæˆ–ä½¿ç”¨ `INPUT_PULLUP`ï¼‰

### å¼•è„š
- LED â†’ GPIO 5  
- æŒ‰é”® â†’ GPIO 4ï¼ˆæ¥ GNDï¼Œä½¿ç”¨å†…éƒ¨ä¸Šæ‹‰ï¼‰

### ä¾èµ–åº“
- æ— ï¼ˆä»…ç”¨ Arduino æ ¸å¿ƒï¼‰

### `SmartBreathingLED.ino`
```cpp
#define LED_PIN 5
#define BUTTON_PIN 4

enum Mode { BREATHING, ON, BLINKING };
volatile Mode currentMode = BREATHING;

const int PWM_CHANNEL = 0;
const int PWM_FREQ = 5000;
const int PWM_RESOLUTION = 8;

unsigned long lastUpdateTime = 0;
int brightness = 0;
int fadeDirection = 1;

unsigned long buttonPressTime = 0;
bool buttonPressed = false;
bool lastButtonState = HIGH;

void setup() {
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  ledcSetup(PWM_CHANNEL, PWM_FREQ, PWM_RESOLUTION);
  ledcAttachPin(LED_PIN, PWM_CHANNEL);
  Serial.begin(115200);
  Serial.println("Smart Breathing LED Started");
}

void handleButton() {
  bool currentState = digitalRead(BUTTON_PIN);
  if (lastButtonState == HIGH && currentState == LOW) {
    buttonPressTime = millis();
    buttonPressed = true;
  } else if (buttonPressed && currentState == HIGH) {
    unsigned long duration = millis() - buttonPressTime;
    if (duration < 1000) {
      currentMode = (Mode)((currentMode + 1) % 3);
      Serial.printf("Mode changed to %d\n", currentMode);
    } else {
      currentMode = BREATHING;
      Serial.println("Long press: back to breathing");
    }
    buttonPressed = false;
  }
  lastButtonState = currentState;
}

void loop() {
  handleButton();

  unsigned long now = millis();
  if (now - lastUpdateTime > 10) {
    lastUpdateTime = now;

    switch (currentMode) {
      case BREATHING:
        brightness += fadeDirection;
        if (brightness <= 0 || brightness >= 255) {
          fadeDirection = -fadeDirection;
        }
        ledcWrite(PWM_CHANNEL, brightness);
        break;
      case ON:
        ledcWrite(PWM_CHANNEL, 255);
        break;
      case BLINKING:
        ledcWrite(PWM_CHANNEL, ((now / 200) % 2) ? 255 : 0);
        break;
    }
  }
}
```

---

## ğŸ“ é¡¹ç›® 2ï¼šå¸¦æ»¤æ³¢çš„æ¨¡æ‹Ÿè¯»å– + å¼‚å¸¸æ£€æµ‹

### åŠŸèƒ½
æ»‘åŠ¨å¹³å‡æ»¤æ³¢ ADC + å¼€è·¯/çŸ­è·¯æ£€æµ‹ + Serial Plotter æ”¯æŒ

### ç¡¬ä»¶
- ç”µä½å™¨ï¼ˆ10kÎ©ï¼‰
- ESP32ï¼ˆGPIO 34 ä¸º ADC è¾“å…¥ï¼‰

### å¼•è„š
- ç”µä½å™¨ä¸­è„š â†’ GPIO 34  
- ä¸¤è¾¹ â†’ 3.3V å’Œ GND

### ä¾èµ–åº“
- æ— 

### `FilteredAnalogRead.ino`
```cpp
#define ADC_PIN 34
#define FILTER_SIZE 10

float readings[FILTER_SIZE] = {0};
int readIndex = 0;
float total = 0;
float average = 0;

void setup() {
  Serial.begin(115200);
  // åˆå§‹åŒ–æ»‘åŠ¨çª—å£
  for (int i = 0; i < FILTER_SIZE; i++) {
    readings[i] = analogRead(ADC_PIN);
    total += readings[i];
  }
  average = total / FILTER_SIZE;
}

void loop() {
  total -= readings[readIndex];
  readings[readIndex] = analogRead(ADC_PIN);
  total += readings[readIndex];
  readIndex = (readIndex + 1) % FILTER_SIZE;
  average = total / FILTER_SIZE;

  // å¼‚å¸¸æ£€æµ‹ï¼ˆ0~4095ï¼‰
  if (average < 50) {
    Serial.println("ALERT: Possible short to GND!");
  } else if (average > 4000) {
    Serial.println("ALERT: Possible open circuit!");
  }

  // ä»…è¾“å‡ºæ•°å€¼ï¼Œä¾› Serial Plotter ä½¿ç”¨
  Serial.println(average);

  delay(50);
}
```

---

## ğŸ“ é¡¹ç›® 3ï¼šå¤šä¼ æ„Ÿå™¨ IÂ²C æ€»çº¿ç®¡ç†ï¼ˆOLED + æ¸©åº¦ + å…‰ç…§ï¼‰

### åŠŸèƒ½
åŒæ—¶é©±åŠ¨ OLEDã€DS18B20ï¼ˆOneWireï¼‰ã€BH1750ï¼ˆIÂ²C å…‰ç…§ï¼‰

### ç¡¬ä»¶
- SSD1306 OLEDï¼ˆIÂ²Cï¼‰
- DS18B20ï¼ˆé˜²æ°´ï¼‰
- BH1750 å…‰ç…§ä¼ æ„Ÿå™¨
- 4.7kÎ© ä¸Šæ‹‰ç”µé˜»ï¼ˆDS18B20 DATA çº¿ï¼‰

### å¼•è„š
- OLED SDA â†’ GPIO 21, SCL â†’ GPIO 22  
- DS18B20 â†’ GPIO 13  
- BH1750 SDA/SCL â†’ åŒ OLEDï¼ˆIÂ²C å…±äº«ï¼‰

### ä¾èµ–åº“ï¼ˆé€šè¿‡ Arduino IDE åº“ç®¡ç†å™¨å®‰è£…ï¼‰
- `Adafruit SSD1306` by Adafruit  
- `Adafruit GFX Library` by Adafruit  
- `DallasTemperature` by Miles Burton  
- `OneWire` by Paul Stoffregen  
- `BH1750` by claws

### `MultiSensorI2C.ino`
```cpp
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <BH1750.h>

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

OneWire oneWire(13);
DallasTemperature sensors(&oneWire);
BH1750 lightMeter;

void scanI2C() {
  Serial.println("Scanning I2C bus...");
  byte count = 0;
  for (byte addr = 1; addr < 127; addr++) {
    Wire.beginTransmission(addr);
    byte error = Wire.endTransmission();
    if (error == 0) {
      Serial.printf("Found device at 0x%02X\n", addr);
      count++;
    }
  }
  if (count == 0) Serial.println("No I2C devices found");
}

void setup() {
  Serial.begin(115200);
  Wire.begin(21, 22); // SDA=21, SCL=22

  scanI2C();

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println("OLED init failed!");
    while (1);
  }
  if (!lightMeter.begin(BH1750::CONTINUOUS_HIGH_RES_MODE)) {
    Serial.println("BH1750 not found!");
  }

  sensors.begin();
  display.clearDisplay();
  display.display();
  Serial.println("Multi-sensor system ready");
}

void loop() {
  sensors.requestTemperatures();
  float temp = sensors.getTempCByIndex(0);
  float lux = lightMeter.readLightLevel();

  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  display.printf("Temp: %.1f C\n", temp);
  display.printf("Light: %.0f lux\n", lux);
  display.printf("Uptime: %lus", millis() / 1000);
  display.display();

  delay(1000);
}
```

---

## ğŸ“ é¡¹ç›® 4ï¼šä¸­æ–­æŒ‰é”® + ä½åŠŸè€—å”¤é†’

### åŠŸèƒ½
å¤–éƒ¨ä¸­æ–­å¤„ç†æŒ‰é”® + æ·±åº¦ç¡çœ å”¤é†’

### ç¡¬ä»¶
- æŒ‰é”® â†’ GPIO 4ï¼ˆæ¥ GNDï¼‰

### å¼•è„š
- æŒ‰é”® â†’ GPIO 4

### ä¾èµ–åº“
- æ— 

### `InterruptButtonSleep.ino`
```cpp
#define BUTTON_PIN 4

volatile bool wakeUp = false;

void IRAM_ATTR buttonISR() {
  wakeUp = true;
}

void setup() {
  Serial.begin(115200);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), buttonISR, FALLING);

  // å¯ç”¨å¤–éƒ¨å”¤é†’ï¼ˆå¯é€‰ï¼Œæœ¬ä¾‹ç”¨ä¸­æ–­ï¼‰
  esp_sleep_enable_ext0_wakeup(GPIO_NUM_4, 0); // ä½ç”µå¹³å”¤é†’

  Serial.println("Press button to wake or trigger interrupt");
  delay(1000);
}

void loop() {
  if (wakeUp) {
    wakeUp = false;
    Serial.println("Button pressed! Doing work...");
    delay(100); // æ¨¡æ‹Ÿå·¥ä½œ
    Serial.println("Going to deep sleep. Press button to wake.");
    delay(500);
    esp_deep_sleep_start();
  }
  delay(10);
}
```

---

## ğŸ“ é¡¹ç›® 5ï¼šFreeRTOS å¤šä»»åŠ¡ï¼ˆä¼ æ„Ÿå™¨ + æ˜¾ç¤ºï¼‰

### åŠŸèƒ½
ä¸¤ä¸ª FreeRTOS ä»»åŠ¡ï¼šè¯»å–æ¸©åº¦ã€æ‰“å°æ¸©åº¦ï¼Œé€šè¿‡é˜Ÿåˆ—é€šä¿¡

### ç¡¬ä»¶
- DS18B20 â†’ GPIO 13

### å¼•è„š
- DS18B20 â†’ GPIO 13

### ä¾èµ–åº“
- `OneWire`  
- `DallasTemperature`

### `FreeRTOSTasks.ino`
```cpp
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/queue.h>
#include <OneWire.h>
#include <DallasTemperature.h>

QueueHandle_t tempQueue;
#define SENSOR_PIN 13

OneWire oneWire(SENSOR_PIN);
DallasTemperature sensors(&oneWire);

void tempReaderTask(void *pvParameters) {
  sensors.begin();
  while (1) {
    sensors.requestTemperatures();
    float temp = sensors.getTempCByIndex(0);
    xQueueSend(tempQueue, &temp, portMAX_DELAY);
    vTaskDelay(pdMS_TO_TICKS(2000));
  }
}

void displayTask(void *pvParameters) {
  float temp;
  while (1) {
    if (xQueueReceive(tempQueue, &temp, portMAX_DELAY) == pdTRUE) {
      Serial.printf("[DisplayTask] Temp: %.2fÂ°C\n", temp);
    }
  }
}

void setup() {
  Serial.begin(115200);
  tempQueue = xQueueCreate(10, sizeof(float));

  xTaskCreate(tempReaderTask, "TempReader", 2048, NULL, 2, NULL);
  xTaskCreate(displayTask, "Display", 2048, NULL, 1, NULL);
}

void loop() {
  vTaskDelay(pdMS_TO_TICKS(1000));
}
```

---

## ğŸ“ é¡¹ç›® 6ï¼šæ·±åº¦ç¡çœ  + å®šæ—¶å”¤é†’

### åŠŸèƒ½
æ¯ 10 ç§’å”¤é†’ï¼Œè¯»å– ADCï¼Œå†ç¡çœ 

### ç¡¬ä»¶
- ç”µä½å™¨ â†’ GPIO 34

### å¼•è„š
- ADC â†’ GPIO 34

### ä¾èµ–åº“
- æ— 

### `DeepSleepTimer.ino`
```cpp
#define ADC_PIN 34

void setup() {
  Serial.begin(115200);
  Serial.println("Waking from deep sleep...");

  // è¯»å–ä¼ æ„Ÿå™¨
  int adcValue = analogRead(ADC_PIN);
  Serial.printf("ADC: %d\n", adcValue);

  // ç­‰å¾…ä¸²å£è¾“å‡ºå®Œæˆ
  delay(100);
  Serial.flush();

  // è®¾ç½® 10 ç§’åå”¤é†’
  esp_sleep_enable_timer_wakeup(10 * 1000000ULL);
  Serial.println("Going to deep sleep...");
  delay(100);

  esp_deep_sleep_start();
}

void loop() {}
```

---

## ğŸ“ é¡¹ç›® 7ï¼šWeb é…ç½‘ + OTA + NVS å­˜å‚¨

### åŠŸèƒ½
AP é…ç½‘ç½‘é¡µ + Wi-Fi è‡ªåŠ¨è¿æ¥ + OTA æ›´æ–° + å‚æ•°æŒä¹…åŒ–

### ç¡¬ä»¶
- æ— é¢å¤–ç¡¬ä»¶

### ä¾èµ–åº“
- æ— ï¼ˆä½¿ç”¨ ESP32 å†…ç½® WebServer å’Œ Updateï¼‰

### `WiFiConfigOTA.ino`
```cpp
#include <WiFi.h>
#include <WebServer.h>
#include <Update.h>
#include <nvs_flash.h>
#include <nvs.h>

WebServer server(80);

const char* apSSID = "ESP32-Setup";
const char* apPass = "12345678";

String ssid = "";
String password = "";

bool loadWiFiConfig() {
  nvs_handle_t my_handle;
  esp_err_t err = nvs_open("wifi_cfg", NVS_READONLY, &my_handle);
  if (err != ESP_OK) return false;

  size_t len;
  nvs_get_str(my_handle, "ssid", NULL, &len);
  ssid = String(len, '\0');
  nvs_get_str(my_handle, "ssid", &ssid[0], &len);

  nvs_get_str(my_handle, "pass", NULL, &len);
  password = String(len, '\0');
  nvs_get_str(my_handle, "pass", &password[0], &len);

  nvs_close(my_handle);
  return true;
}

void saveWiFiConfig(const String& s, const String& p) {
  nvs_handle_t my_handle;
  nvs_open("wifi_cfg", NVS_READWRITE, &my_handle);
  nvs_set_str(my_handle, "ssid", s.c_str());
  nvs_set_str(my_handle, "pass", p.c_str());
  nvs_commit(my_handle);
  nvs_close(my_handle);
}

void handleRoot() {
  String html = R"rawliteral(
  <html><body>
  <h2>ESP32 Wi-Fi Setup</h2>
  <form method='POST' action='/save'>
    SSID: <input name='ssid' required><br><br>
    Password: <input name='pass' type='password' required><br><br>
    <input type='submit' value='Save & Reboot'>
  </form>
  </body></html>
  )rawliteral";
  server.send(200, "text/html", html);
}

void handleSave() {
  String newSSID = server.arg("ssid");
  String newPass = server.arg("pass");

  saveWiFiConfig(newSSID, newPass);
  server.send(200, "text/plain", "Saved! Rebooting in 2 seconds...");
  delay(2000);
  ESP.restart();
}

void setup() {
  Serial.begin(115200);
  nvs_flash_init();

  if (loadWiFiConfig()) {
    Serial.printf("Connecting to %s...\n", ssid.c_str());
    WiFi.begin(ssid.c_str(), password.c_str());
    uint8_t retry = 0;
    while (WiFi.status() != WL_CONNECTED && retry < 20) {
      delay(500);
      Serial.print(".");
      retry++;
    }
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\nConnected!");
      Serial.print("IP: "); Serial.println(WiFi.localIP());
      // å¯åœ¨æ­¤å¯åŠ¨ Web æ§åˆ¶ç•Œé¢
      return;
    }
  }

  // å¯åŠ¨ AP é…ç½‘
  Serial.println("Starting AP for configuration");
  WiFi.softAP(apSSID, apPass);
  IPAddress IP = WiFi.softAPIP();
  Serial.print("AP IP: "); Serial.println(IP);

  server.on("/", HTTP_GET, handleRoot);
  server.on("/save", HTTP_POST, handleSave);
  server.begin();
}

void loop() {
  if (WiFi.status() == WL_CONNECTED) {
    // æ­¤å¤„å¯æ·»åŠ  OTA æˆ– Web æ§åˆ¶é€»è¾‘
    // ç®€åŒ–ï¼šä»…ä¿æŒè¿æ¥
  } else {
    server.handleClient();
  }
  delay(100);
}
```

---

## ğŸ“¦ å¦‚ä½•ä½¿ç”¨è¿™äº›å·¥ç¨‹ï¼Ÿ

### æ–¹æ³• 1ï¼šArduino IDE
1. æ‰“å¼€ Arduino IDE
2. **æ–‡ä»¶ > æ–°å»º**ï¼Œç²˜è´´å¯¹åº” `.ino` ä»£ç 
3. å®‰è£…æ‰€éœ€åº“ï¼ˆé€šè¿‡ **å·¥å…· > ç®¡ç†åº“**ï¼‰
4. é€‰æ‹©å¼€å‘æ¿ï¼š**ESP32 Dev Module**
5. ä¸Šä¼ ï¼

### æ–¹æ³• 2ï¼šPlatformIOï¼ˆæ¨èï¼‰
åˆ›å»ºæ–°é¡¹ç›®ï¼Œé€‰æ‹© `Espressif ESP32 Dev Module`ï¼Œå°†ä»£ç æ”¾å…¥ `src/main.cpp`ï¼ˆéœ€æ”¹ `.ino` ä¸º `.cpp` æ ¼å¼å¹¶åŠ  `#include <Arduino.h>`ï¼‰ï¼Œåº“åœ¨ `platformio.ini` ä¸­å£°æ˜ï¼Œä¾‹å¦‚ï¼š
```ini
[env:esp32dev]
platform = espressif32
board = esp32dev
framework = arduino
lib_deps =
  adafruit/Adafruit SSD1306
  adafruit/Adafruit GFX Library
  milesburton/DallasTemperature
  paulstoffregen/OneWire
  claws/BH1750
```

---

## âœ… æ€»ç»“

è¿™ 7 ä¸ªå®Œæ•´é¡¹ç›®è¦†ç›–äº†ï¼š
- GPIO æ•°å­—è¾“å…¥/è¾“å‡º
- ADC/PWM æ¨¡æ‹Ÿä¿¡å·
- OneWire / IÂ²C / UART æ€»çº¿
- ä¸­æ–­ä¸ä½åŠŸè€—
- FreeRTOS å¤šä»»åŠ¡
- Web é…ç½‘ä¸ OTA
